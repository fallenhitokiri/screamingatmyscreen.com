<?xml version="1.0" encoding="utf-8" ?>

<rss version="2.0">

    <channel>
        <title>screaming at my screen!</title>
        <link>http://screamingatmyscreen.com/</link>
        <description>what's hot</description>
        <language>en-en</language>
        <copyright>you!</copyright>
        <pubDate>2013-07-16 12:38:12.813048 GMT</pubDate>

        
            
            <item>
                <title>Should I rewrite my app in Go for better scalability?</title>
                <link>http://screamingatmyscreen.com/2013/7/should-i-rewrite-my-app-in-go-for-better-scalability/</link>
                <description><p>In the past few months we have seen many articles about big companies and well known start-ups rewriting a part of their infrastructure in Go. And all articles have one thing in common. They tell you how much faster the app is, how many servers they could turn off and how awesome Go is. Should you do the same and rewrite your app in Go?
<!--MORE--></p>

<p>I have chosen the title because it is a questions I received two times now and I thought a bit longer answer could not hurt. The answer is sadly not just a simple 'yes' or 'no' but more an "it depends on…" type.</p>

<h2>Web development and Go</h2>

<p>There is a great number of different frameworks which are comparable to frameworks you likely know and have used. It starts with pretty simple stuff proving routing and sessions to full featured frameworks which position themselves as counterpart to Ruby on Rails or Django. You will also find libraries for nearly anything you can imagine.</p>

<p>The downside is that they are pretty young, not nearly as feature rich as the libraries you usually use with other languages and not always stable enough for production. If you heavily depend on third party libraries doing the majority of your work and are not willing to fix someone else's code or reinvent the wheel you will likely have a hard time using Go for bigger applications.</p>

<h2>Replacing a Ruby on Rails or Django application</h2>

<p>Do not do this. It is really that easy. If you have a non trivial application using multiple models, controllers and views  it will take a lot of time to rewrite everything and you will not have the same comfort as you have with those two frameworks. All the time you would waste for the rewrite could be invested in cleaning up your codebase, adding new features and improving the performance of your existing app.</p>

<p>The question is not if it is possible - but to answer it: yes, it is - the question is if it is a good idea and a good investment of your time.</p>

<h2>Start thinking SOA</h2>

<p>If you already have a service oriented architecture or if you are planning to split parts away from your gigantic application into smaller services you should consider using Go. I already deployed three services using it and I am quite satisfied with the results.</p>

<h3>From Flask to Gorilla</h3>

<p>There was a service which I hacked together in two or three hours. Nothing impressive. It did three things:</p>

<ol>
<li>Receive data (http POST / JSON)</li>
<li>Store data (redis)</li>
<li>On request process data and send it (http GET / JSON)</li>
</ol>

<p>The service is nothing spectacular or impressive and I believe everyone who is not drunk and has used Python and Flask for more than three hours would have been able to implement it. It is in production for nearly a year and works flawless, but more people started using it and the server sees a lot of load recently, sometimes taking more time than acceptable to respond to requests.</p>

<p>The easy solution would be moving redis to its own server and adding a second application server. I decided to rewrite it in Go. It took a bit more time, but it worked. After I flipped the switch and put it in production the server load moved down, response times got faster and looking at the load it could even be deployed to a smaller server.</p>

<h3>heroku ps:scale web=+2</h3>

<p>In January a friend asked me to help him with a project. He and his company were a bit behind the timeline and they could not afford to be late with this one. They had a solid codebase and already used a SOA. I worked on two services.</p>

<p>Last month we met for a coffee and talked about the Flask application I recently replaced. He was curious why the service was down the first time in a year. He thought about hiring me to replace some of the services with a rewrite in Go. After a short talk about the advantages and disadvantages we came to the conclusion that it would be best to just add additional dynos.</p>

<p>First let us start with some simple math. Two additional Heroku dynos cost them $71 / month. If he would hire me to replace a service we would talk about ~$100 / hour (roughly, we bill each other in Euro). The services are far from trivial, but for the sake of those who do not like complex math imagine I would only need one day to write, test and deploy one service. Two days, with 8 hours of work, are $1600. For this amount of money they could pay the two additional dynos for two years. But what if they unexpectedly need to scale further? Let us add two additional dynos bringing us to $143 / month. We are still around a year of Heroku costs vs development costs.</p>

<p>Another thing to factor in is that neither he nor one of his employees is currently using Go or planning to learn it. Extending or fixing something on one of the services would lead to additional costs.</p>

<h3>When I would consider using Go</h3>

<p>If I would start from scratch or add a new service to an existing infrastructure - and if more people are working on a project someone beside me is familiar with Go - I would not hesitate using it if I would not need many third party libraries.</p>

<h2>Stop talking about scalability and start thinking about costs</h2>

<p>There are some <a href="http://www.techempower.com/benchmarks/#section=data-r6">impressive benchmarks</a> clearly showing what Go is capable of. What some people seem to miss is the fact that more requests per second does not mean it scales better. It just means you can process more requests per second and have to worry about scaling later than sooner.</p>

<p>It is possible that your database will be the bottleneck before you need additional application servers, it could be possible that you will be IO bound but just processing more req/s will not save you from the fact that you need a plan for scaling and in an ideal world a clean codebase enabling you to do so.</p>

<p>What you really should consider, especially if you are just starting with the development of the next world disrupting, society changing, kitten picture sharing service, is the costs associated with developing and running the service. If you cannot afford the server costs all your work, your scaling strategy and everything else is worth nothing.</p>

<p>Most people choose to use Ruby on Rails or Django for a minimal viable product. Fast to develop in, many libraries, cheap contractors, support by many big hosting providers, lots of tutorials,… There are many advantages. But what would you gain if you invest a bit more time in your MVP?</p>

<p>We all know benchmarks suck and we should ignore them but let us assume that Go performs three times better than the same application written in another language. If only half of the benchmarks we have seen are not entirely wrong this should be a safe assumption.</p>

<p>Your typical stack to start with likely looks like this. One server for your app, one for your database. You could put both on the same system but you want to be on the safe side when the millions of cat lovers storm your service. Now someone tells you you should have some backup system if there goes something wrong. You add another app server and a database server. You are successful. More and more users joins your service so you start adding app servers.</p>

<p>This is exactly the moment where it would pay off if you would have invested more time in your MVP. While your typical app can handle 5000 users with one server your Go app now handles 15000. If you are growing fast this can be a lot of money you will safe.</p>

<h3>At least in theory</h3>

<p>Please remember I am not telling you to use Go, no matter what. I am not advocating to throw away RoR or Django. I am not even saying that those benchmarks and theoretical numbers can be reached. We just do not have enough data and real wold examples to prove anything.</p>

<p>And while "invest more time" does sound like an okay tradeoff you should remember that Go and its libraries are young. If do not already now what you will be using, maybe played around with it and have a vague idea if you would have to implement fifty percent of the features you expect from your ORM yourself you could have a bad time seeing a competitor releasing "your product" after a night of heavy drinking and writing PHP.</p>

<p>If you are just starting your future career as developer and want to decide which language you should learn I would suggest you go for Ruby or Python. They are both mainstream and if your kitten picture sharing service does not take off you can easily find a job or some freelance work to make some money for your next ground braking idea.</p>

<h2>Conclusion</h2>

<p>Go is a solid choice. After getting used to it you can likely write code as fast as in another language, it has a promising community and libraries are slowly maturing. While Go itself is pretty robust and feature complete you will have to invest time and effort if you are planning to use third party libraries.</p>

<p>You can succeed and gain many advantages if you choose Go, you can end up with a horrible mess and hate yourself every day for doing something unbelievable stupid.</p>

<p>You should carefully consider your options and the pros and cons. I am currently happy with Go and I will continue using it when it is appropriate but it is not the last language I will ever use and it is not the right tool for every project.</p>
</description>
                <pubDate>2013-07-03 19:32:00</pubDate>
            </item>
            
        
            
            <item>
                <title>http.Request and goroutines</title>
                <link>http://screamingatmyscreen.com/2013/6/http-request-and-goroutines/</link>
                <description><p>I was starting to write a web service using Go this weekend. I already deployed two services replacing a Flask and a Sinatra application but this time was different. It was the first time I found a part in the Go language which did not make sense immediately. Did you ever try to pass a http.Request to a goroutine? Do you want to know what happens if you do?
<!--MORE--></p>

<p>For me, the hardest part using a new language or framework is always the little differences between them and being a bit opinionated after all the years of writing code in different languages. This weekend I encountered the first thing in Go which did not seem right. After some discussions in #go-nuts I understood the issue but I am still not entirely sold on the way it works.</p>

<p>Just as a short side note before we start looking at the code I want to mention that the people in #go-nuts are great. It is one of the really helpful channels on FreeNode and one of the most newbie friendliest ones I am aware of.</p>

<h2>Return as fast as possible</h2>

<p>I want to replace an existing service which does just one simple thing. Accept a CORS request, process some data and save it to the database. The client does not need to know if it succeeded or anything else. It is basically fire and forget.</p>

<p>For simplicity we just use curl to post some data</p>

<pre><code>curl -i http://localhost:8080/api/add --data "foo=bar"
</code></pre>

<p>Since the client does not need to know what happens to our data we should finish the request as fast as possible. Goroutines are great and this is one of the cases where they are the right tool to use.</p>

<p>If the processing is done outside the request handler it should be able to return nearly immediately since spinning up a goroutine is insanely fast. The final service could use channels and be a bit more sophisticated but I wanted to extend it slowly.</p>

<pre><code>package main

import (
    "github.com/gorilla/mux"
      "log"
    "net/http"
    "time"
)

func main() {
    log.Println("Starting server...")

    router := mux.NewRouter()
    router.HandleFunc("/api/add", AddHandler).Methods("POST")

    http.Handle("/api/", router)

    log.Println("Now listening on port 8080")
    http.ListenAndServe(":8080", nil)
}

func AddHandler(respWriter http.ResponseWriter, request *http.Request) {
    respWriter.Header().Set("Content-Type", "application/json")
    go PrintStuff(request)
    respWriter.Write([]byte("Thanks\n"))
}

func PrintStuff(request *http.Request) {
    request.ParseForm()
    time.Sleep(time.Second * 3)
    log.Println(request.PostForm)
}
</code></pre>

<p>Pretty obvious code, isn't it? We spin up a go routine and return a "Thanks". Let us look at the output</p>

<pre><code>envy% go run src/apiserver/server1.go
2013/06/19 17:58:18 Starting server...
2013/06/19 17:58:18 Now listening on port 8080
2013/06/19 17:58:23 map[]
</code></pre>

<p>Why is our map empty? We posted <code>foo=bar</code>! The problem is that the request body is closed, the handler finished executing before our goroutine started processing everything. (At least this is the final explanation I got. If this is still not entirely correct please send me a mail or tweet so I can update the post)</p>

<p>Calling <code>ParseForm()</code> before spinning up the goroutine on the other hand works fine. First we change our code</p>

<pre><code>func AddHandler(respWriter http.ResponseWriter, request *http.Request) {
    respWriter.Header().Set("Content-Type", "application/json")
    request.ParseForm()
    go PrintStuff(request)
    respWriter.Write([]byte("Thanks\n"))
}

func PrintStuff(request *http.Request) {
    time.Sleep(time.Second * 3)
    log.Println(request.PostForm)
}
</code></pre>

<p>And after running curl we should see</p>

<pre><code>envy% go run src/apiserver/server1.go
2013/06/19 18:04:21 Starting server...
2013/06/19 18:04:21 Now listening on port 8080
2013/06/19 18:04:26 map[foo:[bar]]
</code></pre>

<p>Now this solves our problem, right? Kind of but not in an elegant way.</p>

<h3>Half usable request</h3>

<p>This is the part I do not like. I cannot call <code>ParseForm()</code> but I can access <code>PostForm</code>. I would prefer an all or nothing approach. </p>

<p>I am also not sure if everyone would come to the conclusion why this happens after "just" reading the documentation. The last part of the <code>Handler</code> interface gives a hint but neither <code>http.Request</code> nor <code>ParseForm()</code> mention anything related. It is possible that I missed something or just read it wrong but judging from the reactions I got after asking about this my idea was not so obscure.</p>

<p>As I said it may be a problem with being opinionated and having seen other frameworks and languages with a different behavior. I still believe that if I can do "a" I should be able to do "b" on a struct.</p>

<h3>A better solution</h3>

<p>I do not talk about best practices, I am not experienced enough with Go to do that, but I think you should just ignore the request outside the handler. If only some things are possible you should consider it gone. So we have to pass our data to the goroutine in a different way.</p>

<p>Using a simple map our code would look like this</p>

<pre><code>func AddHandler(respWriter http.ResponseWriter, request *http.Request) {
    respWriter.Header().Set("Content-Type", "application/json")
    request.ParseForm()

    body := make(map[string][]string)
    body["foo"] = request.PostForm["foo"]
    go PrintStuff(body)

    respWriter.Write([]byte("Thanks\n"))
}

func PrintStuff(body map[string][]string) {
    time.Sleep(time.Second * 3)
    log.Println(body)
}
</code></pre>

<p>And let us look at the output</p>

<pre><code>envy% go run src/apiserver/server1.go
2013/06/19 18:26:51 Starting server...
2013/06/19 18:26:51 Now listening on port 8080
2013/06/19 18:26:58 map[foo:[bar]]
</code></pre>

<p>As expected. Moral of the story? Do not pass a request to a goroutine.</p>
</description>
                <pubDate>2013-06-19 21:02:00</pubDate>
            </item>
            
        
            
            <item>
                <title>The new Mac Pro - a great idea, maybe one or two years too early</title>
                <link>http://screamingatmyscreen.com/2013/6/the-new-mac-pro-a-great-idea-maybe-one-or-two-years-too-early/</link>
                <description><p>Many professionals and Mac Pro owners prayed to see the announcement of a new version of their favorite workstation. The reactions differed between "wow, great, take my money" and "oh no, I know you will mess it up". I think the new Mac Pro is a great systems moving in the right direction but eventually one or two years too early and too dependent on Intel.
<!--MORE--></p>

<p>The concept of the new Mac Pro is pretty simple. You buy a base system and if you need any extensions or upgrades you connect them via Thunderbolt. And I think this is the part where most opinions differ.</p>

<p>The biggest advantage is that you are not bound to a system anymore. If your Mac Pro blows up just attach your disk array to your MacBook and continue working, likely a bit slower, as if nothing happened. Or if MacBooks are fast enough just replace your Mac Pro with one of them in some years if you like. Want a new Mac Pro? Get one and just connect everything you own without worrying about the internal slots you have and the compatibility.</p>

<p>In a small, Apple centered, world this could work well. But since we life in the real world we should consider the downsides.</p>

<p>First there is a disturbingly short supply of Thunderbolt hardware. You can get displays and hard disks but everything else is between non existing and "shipment unknown". Maybe Intel is slow on licensing maybe vendors are not thrilled to support another interface. No matter what the reasons are, if we do not see an increase in Thunderbolt enabled hardware I fear it will go the way of Firewire.</p>

<p>The second problem is speed. Thunderbolt, especially Thunderbolt 2, is fast, really fast compared to USB3. But if you consider the speed of PCIe x16 it does not seem so fast anymore. Today I only see high end graphic cards or really big HD arrays running into performance problems. But wait for a year or two when SSDs become cheaper and are more commonly used for mass storage. Or when external arrays start including an option to use a SSD as cache. On the long run Thunderbolt needs to get faster and stay compatible with old versions.</p>

<p>If Thunderbolt would already be faster and if we would see more available hardware I believe most of the criticism Apple got for this move would have been non existent.</p>

<p>I would welcome the idea of extension boxes taking over a significant part of my setup. I am not the target group for a Mac Pro. I could comfortably work with the low end MacBook Air. But if there are HD arrays with SSD caching I could also attach them to my MacBook and send my NAS into retirement. If I start gaming again I could attach a medium to maybe high end graphic card at home while not carrying it with me on the road, saving weight. And if I get a new MacBook I just have to plug in two cables without buying the upgrades I already paid for again.</p>

<p>This can, of course, only happen if Apples strategy with the Mac Pro succeeds. While some digital artists are happy to be able to carry their Mac Pro with them to every shooting location or others who enjoy a new piece of "art" in the living room I just see a great opportunities for every Mac user if everything turns out as planned.</p>
</description>
                <pubDate>2013-06-13 20:28:00</pubDate>
            </item>
            
        
            
            <item>
                <title>Xbox One - a big disappointment</title>
                <link>http://screamingatmyscreen.com/2013/5/xbox-one-a-big-disappointment/</link>
                <description><p>I am not sure if I became one of those "back when I was young everything was better" people or if gaming was just better. Looking at the new Xbox One I have another reason to stay away from gaming consoles, even if I would have enjoyed one. Let me explain why.
<!--MORE--></p>

<p>When I grew up gaming was a big part of my life and this never really changed. I always carried my Gameboy with me like I carry my iPhone today. My first Super Nintendo was enough to keep me in my room for many, well, months if you add up my playtimes. With twelve or thirteen I visited my first LAN party and in the following years I spent a lot of time with my friends gaming on small and big parties. Till the beginning of 2013 I regularly (two to three times a week) raided with my World of Warcraft guild, I played since the end of vanilla, raided since Burning Crusade. I think I can safely say: I am a gamer. And I love being one.</p>

<p>It is a coincidence that it was one year ago that I wrote about <a href="http://www.screamingatmyscreen.com/2012/5/15-years-of-gaming/">15 years of gaming</a> and complained about the current trend that you only get half assed games and that you have to pay for additional content which you used to get for free.</p>

<h2>You do not own your game</h2>

<p>It is no secret that I hate games which require you to authenticate against DRM servers. They break, you need a working Internet connection to play single player games - the word working is the problem. Our ISP needed two weeks to fix a problem, two weeks where most of the current games just would not have worked - and if a publisher goes out of business the servers are likely going with them.</p>

<p>One advantage of consoles was always that you have a (today likely an optical one) medium you insert into a box and start playing. No setup, no drivers to mess around with, just playing a game. Now this is gone. Install the game and bind it to your Xbox live account. And this is not the worst thing.</p>

<p>Have you ever borrowed a game from a friend to play it for some weeks? Well, you are out of luck if he wants to use his Xbox live account. You cannot just borrow games anymore. They are bound to an account. This was the most basic thing if two people owned the same console, it was even the reason for friends to get the same consoles so they could share games.</p>

<h2>Entertainment systems and cameras</h2>

<p>I am pleased to see that Microsoft cares so much about my digital life that they want to be the center of it. They want to control my whole home cinema. Scanning my room to recognize my face and gestures to power on, off and do whatever else with my TV, receiver and amplifier.</p>

<p>But all I want is a gaming console. I do not want a full HD camera scanning the room. I do not want my receiver to switch channels because I started eating a sandwich. I want a gaming console, nothing else.</p>

<p>I would not count this as a negative point in general. I am sure there are people who want this features, I am just not one of them.</p>

<h2>Games, games and even more games</h2>

<p>First thing you should do after you got the new Xbox is throwing away your games for the 360. Or sell them with the console. Or put everything in a corner with the thought that you will, of course, play all of them once again "some day". There is <em>no</em> backward compatibility. Every game you bought is worthless if you only want one console.</p>

<p>If I want to play Final Fantasy 7 today I just search for the discs, install it and start playing. Dozens of PCs and more than a decade later I can still play one of my favorite games. Thanks to Microsoft gamers cannot even play the most bleeding edge game they bought yesterday.</p>

<p>Another thing I find a bit disturbing is that <a href="http://www.polygon.com/2013/5/22/4355306/indie-developers-cannot-self-publish-on-xbox-one">indie developers are not welcome</a>. There are many indie titles which are great or at least promising. They try to deliver content and a storyline, something companies like EA stroked of their checklists many years ago. Even if some of those games do not deliver hundreds of hours playtime they are sold for a reasonable price.</p>

<p>So what games can I get? Likely the same as always. Slightly reworked titles which were first released five or six years ago. I still do not want to play military games or soccer. If I want sports I go outside and play with friends, if I want to see senseless slaughtering in high definition I turn on the news. I am aware that there will be more games than those they showed but it seems to be what they promote because the masses want those games.</p>

<h2>I am really disappointed</h2>

<p>I thought about getting a console again. PC gaming is screwed thanks to publishers and DRM. And now Microsoft introduces the same rubbish to the console world. But beside the fact that I would have to put up with the same stuff I am running away from I cannot trade games, I cannot play older titles and I need an Internet connection for single player games. And the only games I can play are made by publishers who give a damn shit about gamers.</p>

<p>I can only hope that the Playstation 4, once Sony figures out how to assemble the parts so they can actually show us the console, does the basic things right. Slowly I am running out of options.</p>
</description>
                <pubDate>2013-05-23 21:03:00</pubDate>
            </item>
            
        
            
            <item>
                <title>Keep Calm And Tumble On</title>
                <link>http://screamingatmyscreen.com/2013/5/keep-calm-and-tumble-on/</link>
                <description><p>It is all over the news. Yahoo bought Tumblr for $1.1 billion. As usual, after a service is acquired, people fear that Tumblr is dying, starts attaching ads to every <code>&lt;div&gt;</code>, changes colors to match Yahoos purple and, of course, someone starts making profit of cat pictures, rants about food and deep, emotional, whiny black and white memes 13 years old use to tell the world their parents do not love them because they bought them the white and not black iPhone.
<!--MORE--></p>

<p>You should really read Marissa Mayers <a href="http://marissamayr.tumblr.com/post/50902274591/im-delighted-to-announce-that-weve-reached-an">post on Tumblr</a>. There are some statements which should be considered.</p>

<p>First I am aware of the fact that Yahoo proved to be run by people who do not really understand what this fancy thing called Internet is and how it works. Just replacing a CEO will not change the company culture but it is a good start and as far as I know we have no evidence to support the claim that Marissa Mayers does not know what she is doing.</p>

<p>Second it looks like Marissa Mayers and David Karp plan on working together without changing the roadmap Tumblr already had.</p>

<p>They will work together to make sure Tumblr generates money. Lots of money, of course. But does not have to be bad. I already <a href="http://www.screamingatmyscreen.com/2013/1/i-am-the-product-and-that-is-okay/">wrote about the fact</a> that you either pay for a product or that you are the product. I doubt Tumblr would survive if they asked people for money. So they have to use advertisement and they already failed trying it.</p>

<p>Yahoo on the other hand knows how advertisement works and if they work closely with people who know how the Internet, services and how Tumblr works this could be a win-win situation.</p>

<p>The alternative would be Tumblr burning the last money they have, starting to lose money and going out of business or just selling what is left to someone who does not care what happens to the users.</p>

<p>If all this fails there is one thing we should remember: Flickr. After it was bought nothing changed. If this is good or not is stuff for another post, but things did not get worse, it is still usable and as far as I know people did not lose anything.</p>

<h2>But I want to migrate away!</h2>

<p>If you really think you have to move your content to another platform, here are some easy steps.</p>

<p>First download your content with <a href="http://mwunsch.tumblr.com/post/50840768162/backup-your-tumblr-with-tumblr-rb-v2-1-0">tumblr-rb</a>. It is always a good idea to have a backup of what you created.</p>

<p>After you have a backup you should register a domain. No matter if it is "catslookinglikehistoricdictators" or "ihavenoideawhatiamdoing". Make sure you have a domain. After your tumblr account is gone how will people find your new site? If you do not own the domain, you lose nearly everything if you move to a different service. I am currently not aware of one which does not let you use your own domain.</p>

<p>Now you have to decide how to put your content online. The easiest way is using a hosted service like Wordpress or <a href="https://posthaven.com">PostHaven</a>. I think most people know that I am not a big fan of Wordpress. But you should still take a look at it. I heard rumors that there are people who kind of get along with it or something like that. There are many more options but you either know them already or you should really use something hosted which does not require any prior knowledge of websites, hosting and content management systems. You still depend on a 3rd party but since you own the domain you can easily move between services.</p>

<p>There are two things you should know. You will not find a community like Tumblr again or a way to engage as easily as you are used to with other people. You will likely find full featured content management systems confusing, be prepared to spend some time learning your new playground.</p>

<p>Now that you are online again you should start thinking about gaining some knowledge how to host a website yourself so you will never be in the situation that a service is shutting down and you have to do an "emergency-content-migration". If you do not know where to start feel free to drop me a line.</p>

<h2>What should we do now?!</h2>

<p>Time will show what happens to tumblr. But what should we do till we know if migrating to another service is necessary? Keep calm and tumble on.</p>
</description>
                <pubDate>2013-05-20 17:15:00</pubDate>
            </item>
            
        
            
            <item>
                <title>Adobes Creative Cloud is great for professionals, not hobbyists</title>
                <link>http://screamingatmyscreen.com/2013/5/adobes-creative-cloud-is-great-for-professionals-not-hobbyists/</link>
                <description><p>Now that the first rage about Adobes move to only offer the Creative Suite based on a subscription model is gone, we should be able to talk about it like sane human beings. Overall I like the idea and I do not believe it will backfire at Adobe.
<!--MORE--></p>

<p>First let us play a bit with the numbers. We are talking about 60€/month. This means 720€/year or 1480€ for two years. The full suite as Master Collection costs around 3200€. An upgrade is around 1500€.</p>

<p>If you upgrade every second year you are even on running costs but save the one time investment of 3200€. No matter how you calculate your budget this is a good deal, especially if you think about all the additional stuff you get for subscribing to Creative Cloud.</p>

<p>So why did we see a massive shitstorm, rage and discussions? In one word: Hobbyists.</p>

<p>Professional agencies are likely to use the latest version. We do not need to consider the advantage of spending money from time to time. There are two cases which I believe we can agree on:</p>

<ol>
<li>New features are sometimes a nice thing, even if not everything is an improvement.</li>
<li>If you work with freelancers and clients it is likely you want an up to date version if you exchange files.</li>
</ol>

<p>Hobbyists do not care about this. They want to buy a software package and use it. Most of them will not even use 30% of the features they paid for and it makes no sense for them to be priced as a web or advertisement agency e.x. which wants the latest version. A good friend still works with Photoshop 7 and is happy with it for retouching photos.</p>

<p>But Adobe could not care less about hobbyists. Most of them buy one package and maybe one upgrade every few decades (which is AFAIK not possible to upgrade over some major versions but I hope you get my point). While professionals may consider skipping one upgrade or to use other online services an already payed subscription ties them nearer to Adobe.</p>

<p>What are the options for hobbyists? The likely easiest one would be joining the rows of the not-so-legal "I found a copy online which needs no activation" group. But there are also good designed, functional paid alternatives like <a href="http://www.pixelmator.com">Pixelmator</a>, <a href="http://www.flyingmeat.com/acorn/">Acron</a> or free software like Gimp which could be an alternative, depending on your point of view. I think Gimp vs. Photoshop is the vim vs. Emacs for digital artists.</p>

<p>So what does this mean? Adobe wins. Professionals win. Hobbyists lose. It could be that easy if there were not some professionals and small agencies who are comfortable with a slightly outdated version that will be caught in crossfire, which sucks. For me it is okay. I can live with Creative Cloud, I enjoy the additional features and I do not pay more than I would while regularly upgrading.</p>
</description>
                <pubDate>2013-05-18 13:45:00</pubDate>
            </item>
            
        
            
            <item>
                <title>The Cloud Is Fine - You Are Just Using It The Wrong Way</title>
                <link>http://screamingatmyscreen.com/2013/5/the-cloud-is-fine-you-are-just-using-it-the-wrong-way/</link>
                <description><p>This week I have read another article that Google terminated an account without notice and without reason. It described the horrible life without GMail, Picasa, gdrive and all the other services Google offers. The conclusion and the comments were the same I always read when something like this happens: "The cloud is bad!". Well… This is just not true.
<!--MORE--></p>

<p>The first thing everyone should understand is that it is possible to enjoy all the features cloud providers offer and still access your data if one of them thinks it would be funny to check what happens if you just disable swapping on a production server or "just doing a quick fix without testing because it is just one line of code and what could possible go wrong?"</p>

<h2>Use a client, not the webinterface</h2>

<p>The trick is to not use webinterfaces for everything. I am not exactly sure why people do this in the first place since I have never seen anything with less usability than webinterfaces, but this is stuff for a different post. Want to read EMails? Open your mail application. Want to edit documents? There are Office suites, some of them are even free and kind of work. I could go on but I think you have an idea where I am going with this.</p>

<p>What happens if file synchronization service terminates an account? Nothing. All my files are stored locally. What happens if a mail service terminates an account? You guessed right, nothing.</p>

<p>The problem with cloud providers locking accounts is not that you cannot access your files anymore, the problem is that most people do not have a local copy of the files.</p>

<p>Just because you have a local application synchronizing your files, emails and photos does not mean you cannot check your mails with a browser while visiting your parents. A webinterface can be handy sometimes and I also use them from time to time.</p>

<p>First rule using the cloud: "Nothing is better than a file on your hard drive."</p>

<h2>Backups</h2>

<p>You have backups of all your files stored in the cloud, right? Software fails. Hardware fails. Humans fail. Just because not many people lost data stored in the cloud does not mean it is not possible. Still people, smart people who know that backups are important, have no copy of their mails or photos.</p>

<p>Having everything on your local system gives you some room for errors in the cloud. Of course, bad syncs can still happen and kill both datasets. This is no replacement for a real backup, but it can make data corruption on the server less dramatic and it makes real backups easier.</p>

<p>Second rule using the cloud: "The cloud does not replace backups."</p>

<h2>But my provider does not offer…</h2>

<p>"native clients", "local synchronization", "pink unicorns",… It doesn't matter. For every provider which does not there are five which do. You have the choice what you are using. Maybe you do not get "shiny feature x" but what is more important: Accessing your files whenever you need them or having a certain feature you use once a year?</p>

<p>I understand the fascination of "everything runs in the browser". You trade some usability for the fact that everything you need to work is a browser. Only being able to work if you have a Internet connection and another company does a good job is a big disadvantage if you look at the history of nearly all cloud providers.</p>

<p>Third rule using the cloud: "You have the choice what service you are using."</p>

<h2>Use the cloud for everything!</h2>

<p>This is no rant against cloud services. I use iCloud, Dropbox and other services on a regular basis but if one of them goes down, if one of them terminates my account I can continue working like nothing happened. My projects are still on my HD, my contacts are still on my phone and if everything fails at the same time I have a backup.</p>

<p>Using the cloud is a good idea. Using it brainlessly, especially for your business, is not.</p>
</description>
                <pubDate>2013-05-05 20:13:00</pubDate>
            </item>
            
        
            
            <item>
                <title>Is it project fraud or saving the client?</title>
                <link>http://screamingatmyscreen.com/2013/3/is-it-project-fraud-or-saving-the-client/</link>
                <description><p>Imagine the following situation. You are hired to develop an application using Ruby on Rails. But from your experience you decide that Sinatra would be better suited for the job. You just develop the application in Sinatra, deliver, no one notices it and everyone seems to be happy. Do you believe this is okay?
<!--MORE--></p>

<p>Just from the short introduction I would say no. But let me tell you the whole story.</p>

<p>I was called by a potential client and asked to write tests for a Ruby on Rails project. 75 controllers and 25 models (the number was specified by the developer on his final report) which never have seen one line of testing. The last time I talked to him about the project I should now add tests to I suggested giving the job to someone I know. But since I had two meetings with the client, let us call him Bob to make it a bit more personal, I knew a bit about him.</p>

<p>Bob has no idea about anything digital. But he loves to listen to buzzword bullshit bingo. And most of the time he believes he needs what he hears. He already has an intranet for his company and wanted to extend it with said project. And because every cool start-up uses it the project had to be done using Ruby on Rails. Without going into too much details it was "only" an API. Fetching information from various sources, merging them into one output stream to be included in the existing intranet.</p>

<p>Bob was not satisfied with the one who developed the solution, we call him Jack, so he called me. He heard that it is important to test software and his system administrator told him that there are no tests for the API-project. They plan to extend the project and add functionality. To do it "right" they insist on a full test coverage of the code base.</p>

<p>After checking out the source code I was a bit surprised. It is based on Sinatra. I called Bob and he did not understand why it was not written in Ruby on Rails. He made it clear that he wants a Ruby on Rails application. I called Jack and he told me that he believed Sinatra was the better choice and that the contract did not specify the framework, even if the client explicitly talked about it the whole time.</p>

<p>Now back to the main question: Is this fraud?</p>

<p>From what I can tell Sinatra was an acceptable choice. I do not believe that it is true that a Ruby on Rails application would have taken significantly more time to develop and as a result be more expensive. We talk about "hammer API endpoints, fetch data, save to database, generate stuff from database, safe to database, provide an API to fetch generated stuff". Rails should be fine, too.</p>

<p>The main problem we are talking about is pretty easy. Bob orders A and Jack believes B is the better choice. Since the contract does not specify A he choses B, knowing that Bob wants A.</p>

<p>Is it fraud? Maybe not from a legal point of view. (Disclaimer: I am not a lawyer. It is possible that spoken arrangements can be legally binding in some countries.) But in my opinion it is highly unprofessional and unethical.</p>

<h2>How to handle such a situation?</h2>

<p>If I am sure solution B is better for Bob it is my job to explain it to him in a way he can understand. If he still insists on Ruby on Rails it is either because there are reasons he did not and maybe does not want to mention or because I suck at explaining.</p>

<p>This is an important lesson anyone planing a project with a client has to learn. If you are not able to convince the client you have the best solution for the given problem it is your fault, no the clients. Do not start with "the client is to stupid to understand that…". You are the one who is selling. It is your job to make sure he understands why he should trust you. If you are not able to do this because "selling is only for those who {have shitty products, do not know what they are doing, those people I hate,…} or you are too elitist to explain something in an understandable way it is not your clients fault.</p>

<p>If you cannot sell and do not want to learn how to sell properly there is only one way to go. Deliver what the client asked for. Maybe Sinatra is the better choice. But the client believes he gets a Ruby on Rails application, which he ordered, and this is what he should get. There is no reasoning to justify anything else.</p>

<p>If you want to help your client making the right decisions, which is in my opinion a good thing, it is your job to be good enough at selling your ideas.</p>

<p>If you do not want to become good enough but still believe customers should get what they need not what they want you have to options. Hire someone for the job or stop working directly with clients. But do not deliver something they did not ask for.</p>

<p>What do you want your client to tell people asking about you? "He suggested a different technology, saved me money and delivered a great project" or "He delivered something I did not ask for."</p>

<p>I would love to hear your opinion. Do you believe this was fraud? Do you believe you have to save a client from making the wrong decisions? How far can you go to save a client?</p>

<p>Update: Discussion on <a href="https://news.ycombinator.com/item?id=5462469">HackerNews</a></p>
</description>
                <pubDate>2013-03-29 19:31:00</pubDate>
            </item>
            
        
            
            <item>
                <title>One Weekend With Go</title>
                <link>http://screamingatmyscreen.com/2013/3/one-weekend-with-go/</link>
                <description><p>After reading many positive things about the Go language I decided to give it a try. I spent one weekend reading about the basics, some more detailed stuff I am especially interested in and worked my way through the first examples and some tutorials. I have to admit I am a bit torn between "wow, great language" and "meh, not sure if I like it".
<!--MORE--></p>

<p>These days I primarily do two things. Writing backend code in Python, most of the time using Django and Flask, or developing iOS applications with Objective-C and Xcode. After I read about Go I was not sure if I should be interested. It is developed by some highly respected people, sponsored by one of the biggest companies and praised for many different things. I am happy with my current tools and languages. Being a bit curious, I could not resist. Even if I would not use it for anything, learning something new, even if only the basics to be able to read some code, can always be handy.</p>

<p>There are several things I expect from any language I use. Most of the time I am free to decide what works best for a given project and just use it, so there have to be use cases where Go shines to be considered an option in my toolbox.</p>

<h2>Editors and IDEs</h2>

<p>I have to admit I am one of those people who love Xcode. It is not the best IDE, it does not have the most features, it is not the fastest one and it has some flaws. But for me it is a great package and works fine. For Java I preferred NetBeans. I am not sure how good it performs today, since the last time I wrote Java was around 2004. </p>

<p>I do not need an IDE. But if I use an editor I want some basic stuff like code intel that actually works and working auto indent. If you believe this is always given you never tried Textmate 2. I will not discuss the IDEs and editors, so a quick conclusion: SublimeText 2 and vim work great. For bigger projects I would still prefer an IDE with some refactoring magic. I was not able to find one I actually like.</p>

<h2>Some basics about the language</h2>

<p>I want to work with a clean, easy to read and write, language, with stable 3rd party libraries and a complete toolchain. Most topics people see as a reason for holy crusades like statically typed vs dynamically typed languages do not matter for me. I have my preferences and I know how to take advantage of both of them and how to navigate around the consequences.</p>

<h3>Syntax</h3>

<p>Every time I learn a new language the first thing I look at is some source code. After spending too much time with Perl I developed a pretty strong feeling towards languages which are easy to read. Python is basically what I love. A clear style guide, most of the time one obvious way to do something and no unnecessary clutter.</p>

<p>Go is not bad. But it is also not Python. You have mustaches, stars for your pointers and some stuff which just looks plainly wrong at the beginning but which makes a lot of sense if you understand what actually happens. I would say it is okay. Not the most elegant language but still okay to work with.</p>

<h3>Statically vs dynamically typed</h3>

<p>I have to admit I prefer statically typed languages. Catching obvious errors at compile time saves me a lot of trouble, testing and doing the same things over and over again. Go is statically typed. For me this is a point on the plus site.</p>

<p>If you believe in dynamically typed languages and feel like someone smashed your kneecaps if you are forced to use something else Go is likely not for you.</p>

<h3>Style guides and folder structures</h3>

<p>Go has a nice, little tool which formats you code according to some best practices and style guides. I do not agree with every style decision as I do not agree with everything in PEP8. Even if you do not use it (you should!), if you want to read some source code which just looks plain ugly and nearly unreadable, a nicer version is one command, <code>go fmt</code>, away.</p>

<p>The folder structure first looks a bit confusing and unnecessary bloated, but after some time, fetching packages, cross compiling, etc. I slowly understand why they suggest the this particular structure. As with code style, you are free to disagree and use something else.</p>

<p>The fact that I can use something the authors of the language do not prefer is a big plus point. Sometimes there are reasons to break with the style guides or best practices. Never less I believe in sticking to officially declared best practices as often as possible. It helps contributors a lot if they do not have to learn one new coding standard for every project they start working on.</p>

<h3>Tools, tools and more tools</h3>

<p>You get many handy tools out of the box. Maybe some descriptions are not the most accurate, but it should be enough to give you an idea what is included.</p>

<p><code>get</code> downloads packages and projects, <code>fmt</code> formats your code according to the official style guide, <code>fix</code> to make sure your programs and libraries are compatible with new versions and <code>doc</code> giving you, most of the time, many handy informations about packages and functions. Just to name some of them.</p>

<h3>Not as object oriented as you might think</h3>

<p>In Go you have structs and functions. Something which looks like a class and something which looks like inheritance. Do not let it fool you, even if it looks this way, it is not.</p>

<p>What I found refreshing, to my own surprise, is how clear and easy it looks if you just define a struct and some functions which belong to it. It does not make such a big difference to defining a class and adding methods, but every time I write one or look at one I got this "this is just clear and so right" feeling.</p>

<p>I will not explain the whole concept. There are many good posts pointing out the differences and if you are interested in the language you will find the documentation containing the informations pretty quickly and early.</p>

<h2>The good parts</h2>

<p>There are several things I like and one special thing I just love. And this is not exaggerated. It was one of the reasons why I was interested in Go. There are, as in most languages, some parts that just feel right and after using and understanding them you have to think "why did no one else do this?!".</p>

<h3>Cross compilation</h3>

<p>I currently develop on an MacBook running OSX 10.7.5. My servers either run Debian/Ubuntu or FreeBSD. Every time I add a new VM, jail or maybe a server for a client project I setup nginx or lighttpd, sometimes a database, some kind of key value store and so on. To deploy a web application written in Python and Django I setup an virtualenv, install build tools, install dependencies and libraries and upload the project.</p>

<p>Do you know what is really fun? If you run apt-get update; apt-get upgrade and your virtualenv dies because someone screwed up (I am looking at you Ubuntu).</p>

<p>Something works fine on your local system and breaks while on the testing system or even worse in production because a library could not be updated or is installed in a slightly different version or compiled with other parameters? This should not happen, especially not from testing to production, but you have to take care of it.</p>

<p>And here comes Go. I wrote a small web and socket server to test some things, compiled it for Windows, copied it to my significant others gaming systems and it just worked. Without installing Go or libraries and anything else. It just worked.</p>

<p>For me, this is refreshing. If it compiles and works just copy the binary and you are done. No pip and bundler, no rvm and virtualenv, no version checking. One binary.</p>

<h3>Standard library</h3>

<p>I believe there is not much you will miss. HTML templating, networking, IO, you name it and it is likely there. I believe you can crunch numbers, write web applications and do mostly everything that comes to your mind with the standard library. I do not use Go long enough to validate this point or point out the differences between Go and Python, but from a quick look it is pretty complete.</p>

<h3>Concurrency</h3>

<p>I wrote stuff with gevent, twisted and Node.js. I have been in callback hell. I have worked with threads in Java and C++. From what I have seen channels and go routines are by far the most easy to use implementation to let stuff happen simultaneously.</p>

<p>It does not make your code ugly or forces you into a code style you never had or have to use for anything else. </p>

<h3>Performance</h3>

<p>From some quick and dirty tests Go is fast. I will not make any comparisons. I have no scientifically acquired numbers and I have no real tests or highly optimized code. I did a quick implementation of a service in Go which mimics an existing service running in production using twisted. It seems to be faster. Before I have "real numbers" I will not say anything else about performance. There are already too many false claims and useless charts, I do not have to contribute to this waste of bandwidth.</p>

<p>As a side note: Compilation time is also pretty good.</p>

<h2>The bad parts</h2>

<p>Not everything is great. There are, as most of the time, some dark corners or things you would like to be different. Go is one of the youngest languages used in production I know of. Everything needs some time, so some of the next points should not be considered too bad. They can changed.</p>

<h3>Libraries</h3>

<p>Let us say you want to write a web application but you do not want to invent everything from ORM to templating yourself. I believe everyones standard reaction is to look for a web framework. Django, Flask, Ruby on Rails and Sinatra are well known frameworks and for most of us one of them is the first package to install if we talk about developing a web application.</p>

<p>Searching for web frameworks for Go is a bit like looking at a drawing book of a 6 year old. On the first five pages you think he understood which color he should use for human skin and on the sixth page he draws a blue women. On page 8 he just does not draw hands anymore. </p>

<p>What Go currently completely misses are GUI libraries.</p>

<p>Many libraries are pretty young, sometimes incomplete and not always as stable as you would like them to be. Sometimes it depends on how you use them. The PostgreSQL library worked perfectly fine in my test, other people have problems if they connect regularly for availability checks. If you use Python on a regular basis you are spoiled and will likely be a bit disappointed.</p>

<h3>Pointers</h3>

<p>I just admit it. I prefer pass by reference. It is possible, but it is ugly and I believe most people will consider it bad practice. I am not fully decided on this one, yet.</p>

<h3>Error handling and exceptions</h3>

<p>There are no exceptions. Handling every possible error, sometimes with multiple return values, is a bit painful and troublesome. I would really prefer another approach on this one. Of course, this is a personal preference but every second line being an <code>if (err != nil)</code> is not just ugly and far from elegant but also a lot of work for something that could be a lot simpler.</p>

<h3>Named arguments</h3>

<p>There is no such thing. You can, as you can in Ruby for example, work around this limitation but in my humble opinion this is a dirty way of doing it. An editor or IDE with some sense shows you what a function expects. This makes it bearable but I would still prefer support for named arguments.</p>

<h3>The name is just stupid</h3>

<p>While I do not believe "Go" was a good choice I do not believe it was easier to find something about the programming language one year after Python or Ruby were released.</p>

<p>Time will show if the name becomes "okay" or if we just have to continue searching for "golang".</p>

<h2>Community and adoption</h2>

<p>Nearly every time I searched for some informations the mailing list came up as the top result. What you rarely see is someone blogging about Go beyond the initial "I used Go for x weeks, this is what I think" post.</p>

<p>One of the reasons why I did not mention any libraries or how cross compilation and deployment could look like is because I plan to write separate posts. The other reason is that this post is longer than expected and I did not want to include anything moving too far away from my first impressions.</p>

<p>I hope, as the language becomes more mature, the community will grow to a degree comparable with Python, Ruby and Node.js. In the last few months I have read many blog posts from companies migrating existing solutions to Go. This will definitely help.</p>

<h2>Conclusion</h2>

<p>There is much more about the language than I just talked about but I hope I gave an idea what you can expect from Go. Even if you do not use it right away it can become relevant pretty quickly for the stated reasons.</p>

<p>I am currently working on replacing a Python based service with one written in Go. After the first deployment I can give you more useful informations, but currently my suggestion is that you take a look at Go. I will blog about it, of course. The next posts will be about web frameworks and cross compilation, maybe possible deployment scenarios included.</p>
</description>
                <pubDate>2013-03-20 23:07:00</pubDate>
            </item>
            
        
            
            <item>
                <title>What I learned during 10 years interviewing people - talking about hiring and discrimination</title>
                <link>http://screamingatmyscreen.com/2013/2/what-i-learned-during-10-years-interviewing-people-talking-about-hiring-and-discrimination/</link>
                <description><p>At the moment women in IT is one of the most discussed topics I am aware of. There is no day without new tweets, tumbles and other stuff discussing the topic. After I read <a href="http://ashedryden.com/blog/call-for-perspectives-changing-our-hiring-processes-for-diversity">Ashes</a> post I thought about talking about it from the perspective of an employer and someone who had more hiring talks than you can count the last ten years.
<!--MORE--></p>

<p>This post is basically a collection of things I learned from hiring and managing employees and contributors (read: freelancers).</p>

<p>I will briefly talk about my past experience and my hiring process before I start discussing gender diversity. So if you only care for that part just skip the next two sections.</p>

<p>I feel like I should add a big, fat disclaimer, but I refuse to write it in red. These are my experiences. I will not claim to have all the answers, not even one, I do not speak with an absolute authority. I just talk about what I did, how I did it, why I thought it would be a good idea and what I learned. It is possible that you disagree, which is good. Different situations, different people, different ways to handle something. The worst thing you can do after reading this is trying to adopt every single point and act like I did.</p>

<h2>How I learned the essentials</h2>

<p>Thankfully I did not have to learn everything by myself. My father taught me everything possible. He is self-employed as long as I can remember, working for international companies, my mother runs the organizational part of his business. I could always ask them for help and when they saw that I was about to screw up they told me what I was doing wrong when clients were about to be harmed - but otherwise I had to learn my own lessons by myself. And I am really thankful that they did not try preventing me from doing stupid things.</p>

<p>Thanks to my father I grew up with tech everywhere. It was his job and it became my passion. I could solder before being able to do more math than add, subtract, multiply and divide. With 13 I had the opportunity to join a group of people organizing network parties. We had up to 350 gamers and after my first year I was in charge of the network and tournament organization. This was also the first time I had to coordinate and work with others, sometimes just telling them what to do - and I learned a lot.</p>

<p>With 16 I founded my company to be able to charge people for repairing their stuff. Thanks to the fact that I was well known I had the chance to work for small companies. I think my biggest client had around 50 employees. As I turned 18 I started a training as financial consultant, while finishing my university-entrance diploma. I chose to be self employed, learn in the evenings, take the exams for my training on weekends and run two businesses side by side.</p>

<p>I took as many advanced trainings as I possibly could while working (they were offered on a regular basis). I focused on the psychological part of selling, hiring and managing and became an IT coach for around 250 people. This is the part where I stop, because I would waste the next five minutes of your and my life with details that do not really matter, but would explain how everything in this organization fits together. Just to finish this up: This is the business I only manage today, it does not consume much time, my employees basically do everything by themselves, I only make sure the quality is as good as it can be. 90% of my time are used for freelancing, developing and designing things for the web or iOS.</p>

<h2>The hiring process</h2>

<p>Being responsible for other people was a bit scary at the beginning but I quickly noticed that there are some projects where I needed help. Sometimes to stick to the schedule, sometimes to ensure the quality was right.</p>

<p>It was before my 17th birthday that I needed to hire someone. A client asked me to setup 30 workstations, two servers and the network. I asked two friends who I knew from network parties. We agreed on a price and just did it. There was no need for anything but "Do you have time and want to make some money?". I knew them, I knew they can do what was needed.</p>

<p>For my second company I needed some people for growth. I could not satisfy the demand on my own and I wanted to make sure the business still runs when I am not there.</p>

<p>In eight years I interviewed around 300 people, for myself, clients and friends. Believe me one thing: You will see and hear things you never wanted to see or hear. But my top 3 "Oh my god, just go away!" moments are a topic for another post.</p>

<p>I always used a pretty simple interview process. The first question, after I told them what they would have to do, was "Do you believe you are able to do this in a professional way, making sure the quality is excellent?".</p>

<p>If the response is: "Yes I can", it is the point where I would start asking domain specific questions. What I ask depends on what I expect. Highly specialized vs. an all-round talent. Sometimes I ask a specialist I know to attend for the domain specific questions. If customer contact is involved I add questions how he would handle them. Of course, past projects are also interesting. I think you know the different possibilities how to interview someone.</p>

<p>If the candidate response is "I am not sure", the first question is "What do you think would it need that you are able to do it?", followed by "Are you willing to do this to get the job?". There are trial periods, there are time based contracts, there are so many possible ways to see if a candidate is able to learn what he needs. This does not work if you need someone immediately but for the long run I also always consider people who are able to learn.</p>

<p>After the interview I consider the candidate. A standard procedure would be a one week contract, paid, of course, working with the team if there is already one. I do not believe that hiring someone without trial and forcing people who just hate each other on plain sight to work together is a good idea.</p>

<h2>Discrimination and sexism</h2>

<p>I know that women are often paid significantly less than men. I am aware that there is discrimination based on gender, skin color, sexual orientation, religious and political views, and everything else you can think of.</p>

<p>I had one contractor who thought it would be funny to always make the same joke about an interview process involving the cup size of a women. The first time I told him that it is not appropriate, the second time was the last time he was ever seen in my office and company.</p>

<p>I have to admit I do not know how it feels to be discriminated, well - beside jokes I had to take as kid because I was a bit bulky. But I also do not see why we cannot solve this. I sometimes have a really simple black and white view of things.</p>

<p>Inappropriate behavior of any kind should be mentioned in a civilized way and from this point the person should know not to do it anymore. How hard can that be? Millions of years of evolution and still some people claiming to be intelligent are not able to understand someone finds something offensive? Sorry, I just do not get it.</p>

<p>Sometimes it is not obvious if someone feels offended by a certain behavior. Telling this person, the first time it happens, should result in a changed behavior and no hard feelings for calling it out. You know, this stuff called civilized communication. Funny stuff, maybe one day we will all just use it.</p>

<h2>Who do I hire? What are the consequences?</h2>

<p>So, when hiring I look out for three main qualities:
Is the candidate able to deliver, gets the job done and works with the rest of the team? If my interview partner is capable of doing all of this, it's likely that I consider him as an option. I never wanted many employees, as a consequence I always just worked with the necessary minimum plus contractors. Worked exceptionally well for me. But I believe this is business and industry specific.</p>

<p>While asked to help interviewing a candidate for other companies I had not always have a choice who was in front of me, so I will only talk about the people I hired for my two businesses, so I talk about IT and finance, both fields which are, I believe, male dominated.</p>

<p>The ratio of applications from men to women was 5 : 1, sometimes even 10 : 1. The women I interviewed had one thing in common: Most of them were qualified for the position, those who were not were less likely to say: "Yes, I can just learn this, no problem", while I believe around 30-40% of the male candidates lacked some skills but believed they could easily learn them.</p>

<p>Over the years I hired 7 men and 4 women for my own businesses. They were between 20 and 55 when they started, white and colored. I know one of them is gay and one a believing muslim.
The best advice I can give you: diversity is great. Different perspectives, different experiences and knowledge. I did not find a downside. It is a bit more management work, but I do not see this as a problem.</p>

<p>Before the hiring process a salary or rate and bonuses are decided, according to required skills/time etc. Then candidates are interviewed. The problem with this is that there is no room for negotiations and sometimes this is just bad. But on the other hand it easily ensures everyone is treated equally. There is no difference if someone just screwed up or acted out of the way or if I like the person. Salary is the same and bonuses are depending on a work target. Pretty simple. Both industries do not favor anything but skills, this makes this system pretty simple and easy to implement.</p>

<h3>Edge cases</h3>

<p>Several things have to be considered when you have a diverse team. When we have a short meeting I get some cookies and gummy bears. Knowing that one of my employees is muslim means I have to check that he is allowed to eat them, which means gummy bears which do not contain animal starch, etc. Not too hard. I do not really see this as such a big problem as some people claim. Again, millions of years of evolution. We have a brain to use it. Being sure not to exclude someone with such simple things <em>is</em> important.</p>

<p>Some of them have kids. From my experience a women is more likely to take care of a child than a man. Maybe the school is calling or there was an accident or the child gets sick. It could be possible that a women misses two or three days a year because of this. Does it make her less qualified? Is her productivity lower? Work worse? Let me make it short because I never understood this discussions: No. </p>

<p>One of the funniest scenes I remember was a male employee bringing his kid to a six eyes meeting because he could not find a baby sitter. Pretty simple trick: Place a good-natured dog in front of a kid. Problem solved. Did you ever see a kid putting his pacifier in the mouth of a (obviously confused) dog? </p>

<p>30 Minutes later we had discussed everything we needed to continue working on the project, the kid was happy, the dog did not need much attention for the rest of the day and the employee was happy that this problem was solved this way, without drama, discussions, threat or anything else he encountered.</p>

<p>This will not work if there is a big meeting with many people. Especially if there are some who just do not like each other. Or if clients are involved. But as long as we can have a relaxed atmosphere why should I care? Work was done. And it should also be clear that it is an exception. The good thing about a team which likes and respects each other? You do not have to point this out and no one is offended.</p>

<h2>Training new employees</h2>

<p>I trained new employees for another company, overall something around 180, for nearly 4 years. Beside some special events we talk about 12 weeks, one evening a week. (I also trained two people for my business but I believe this is a less significant sum to take a resume.) They had to take an exam after those 12 weeks.</p>

<p>I would have to look up the exact numbers but I would guess around 140 men to 40 women. I have never seen one women fail, while it was common that at least one or two men do not pass. While the course was running the female attendees always worked as you expect it from someone who is professional while male attendees had a tendency to just scream an answer or question in the room or talk to someone else. On two occasions I had to ask two male attendees to leave the room. </p>

<p>Each course had ten to twelve attendees, sometimes they worked as a group. One advice if you ever find yourself in a position where I am your trainer: If you try to flirt with someone who obviously has no interest and clearly shows this, if you get more aggressive or if you generally act out of line with stupid (discriminating, sexist...) jokes, you will leave. You want to be treated as an adult, professional? Act this way and not like a hormone controlled 16 year old.</p>

<h2>How do I work?</h2>

<p>When I was 13 I first read "the hacker manifesto". It correlated with the way I was raised. Maybe this is one of the reasons I liked it so much back then.</p>

<p>I think I was 15 when I had the opportunity to attend some CS classes in an university as guest in my summer holidays. I was sitting in a lounge, trying to understand binary search trees. Someone a friend introduced me to, showed up and asked what I was doing. She wasted her two free hours explaining me the basics on how to implement a B-Tree. The first person explaining something advanced IT related to me (in person) was a woman. I could not have cared less about her gender - there was a person who taught me cool stuff. This was everything that mattered to me. Please do not get me wrong, I also like to see a beautiful women, bonus if she is fscking smart, but this should never influence work.</p>

<p>I judge people on what they do. I could not care less about skin color, sexual orientation or whatever. I want the highest possible quality of work and happy clients and I expect from everyone working with me the same.</p>

<p>I canceled contracts with freelancers and clients because I refuse to work with people who repeatedly believe stupid jokes are funny and do not care if they got told that some people in the room are offended. It does not make a difference for me if I am offended or someone else. I want a pleasant working environment for me, my employees and everyone else in the room.</p>

<h2>You are free to disagree, but...</h2>

<p>You are free to disagree with everything I wrote. You can disagree with the way I hire, you can disagree with the way I handle my team. Is it possible that 10 years are not enough experience? Is it possible that I am too young to see why we cannot just act like tolerant, sane adults? Maybe. Maybe I will see some things different in 10 years from now on. But right know it works just fine. I make a good living, I enjoy every hour of work I do and I can believe I do everything I can to not be part of the problem.</p>

<p>I am not free of guilt. Sometimes I just do not see a problem until someone points it out, sometimes I say something stupid without thinking of every possible interpretation. But I care wether or not someone is offended, I adjust and I try not to repeat mistakes.</p>

<p>I do not have all the answers. I do not know how to solve the big problem. But I do know one thing: Even if you disagree with me, if you just make sure you are not a part of the problem (and even do something against it if possible), then you do not have to become an activist, and still we will see the problem getting smaller. It will not vanish this way, but it will help those who fight it.</p>
</description>
                <pubDate>2013-02-23 21:28:00</pubDate>
            </item>
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
    </channel>

</rss>